#!/bin/bash

# hashcmp
# Checks if two or more hashes are the same
# Catches the first instance of a hash being different

RED="\e[1;31m"
GREEN="\e[1;32m"
NORMAL="\e[0m"

argc=$#
files=("$@")

# Error if two or less argcs
if (( argc < 2 )); then
    echo -e "${RED}[$0] ERROR: Argument count is less than 2.${NORMAL}"
    exit -1
fi


declare -a hashes
count=0
# Check if files exist
for file in "${files[@]}"; do
    if [ ! -f "$file" ]; then
        echo "[$0] Cannot find file '$file'."
        exit -1
    fi

    # Sort $file
    sorted="$(mktemp)"
    trap 'rm -f "$sorted"' EXIT
    echo "$(sort "$file")" > "$sorted"

    # Make a tempfile that stores the contents of $sorted
    sorted_hashes="$(mktemp)"
    trap 'rm -f "$sorted_hashes"' EXIT

    # Cut all but first first field (hash)
    declare -a tmp
    while read line; do
        echo "$(echo "$line" | cut -d ' ' -f1)" >> $sorted_hashes
    done < "$sorted"

    # Append path to sorted cut file to the hashes array
    hashes[$count]="$sorted_hashes"
    count=$((count+1))
done

# Compare each hash file with the first one given
echo "Checking each file against file '${files[0]}'"...
failed=false
for (( i = 1; i < ${#hashes[@]}; i++ )); do
    # Chain-check if they are all the same
    if [[ ! -z "$(diff -q "${hashes[0]}" "${hashes[$i]}")" ]]; then
        echo -e "${RED}${files[$i]}: FAILED${NORMAL}"
        failed=true
    else echo -e "${GREEN}${files[$i]}: OK${NORMAL}"
    fi
done


if [[ $failed == true ]]; then
    exit 1
fi
exit 0
